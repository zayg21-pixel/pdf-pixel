<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>PDF Render WASM Thread Demo</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        body {
            display: flex;
            flex-direction: column;
        }

        #header {
            flex: 0 0 auto;
            padding: 8px;
            background: #f5f5f5;
            border-bottom: 1px solid #ccc;
        }

        #header h1 {
            margin: 0 0 10px 0;
            font-size: 24px;
        }

        #header button {
            margin-right: 5px;
        }

        #canvasContainer {
            flex: 1 1 auto;
            position: relative;
            overflow: hidden;
        }

        /*
         * The canvas is the visual rendering layer. It is sized to the scroll
         * host's client area (excluding scrollbar tracks) and never moves in
         * the DOM. pointer-events: none lets events fall through to the scroll
         * host above it.
         */
        .pdf-panel-canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 1;
        }

        /*
         * The scroll host is a transparent overlay that provides native
         * scrollbars. Its scroll-spacer child is sized to the total content
         * dimensions so the browser knows how far to scroll. Being above the
         * canvas (z-index: 2) it captures all pointer and scroll events.
         */
        .pdf-panel-scroll-host {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: auto;
            z-index: 2;
        }

        #footer {
            flex: 0 0 auto;
            padding: 10px 20px;
            background: #f5f5f5;
            border-top: 1px solid #ccc;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #zoomLevel {
            display: inline-block;
            min-width: 60px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="header">
        <div>
            <input type="file" id="pdfFileInput" accept="application/pdf" style="display:none" />
            <button id="loadPdf">Load PDF</button>
            <button id="zoomOut">Zoom Out</button>
            <span id="zoomLevel">100%</span>
            <button id="zoomIn">Zoom In</button>
            <button id="resetZoom">Reset Zoom</button>
        </div>
    </div>
<div id="canvasContainer">
    <canvas class="pdf-panel-canvas"></canvas>
    <div class="pdf-panel-scroll-host">
        <div class="pdf-panel-scroll-spacer"></div>
    </div>
</div>
<div id="footer">
    <button id="prevPage" disabled>&#8249; Prev</button>
    <span id="pageInfo">-</span>
    <button id="nextPage" disabled>Next &#8250;</button>
    <div id="output"></div>
</div>
    
    
    <!--
        coi-serviceworker.js registers a Service Worker that injects the
        Cross-Origin-Opener-Policy and Cross-Origin-Embedder-Policy headers
        client-side. This is required on GitHub Pages (a static host that
        cannot set HTTP headers) so that SharedArrayBuffer is available for
        Blazor WASM threading. When running locally, Program.cs middleware
        already provides those headers, so the service worker skips registration.
        This script must be a plain (non-module) blocking script loaded before
        the dotnet module to ensure the page reloads before the runtime starts.
    -->
    <script src="coi-serviceworker.js"></script>
    <script type="module">
        import * as canvasInterop from './canvasInterop.js';
        import { dotnet } from './_framework/dotnet.js';

        const { setModuleImports, getAssemblyExports } = await dotnet
            .withDiagnosticTracing(false)
            .withApplicationArgumentsFromQuery()
            .create();

        await canvasInterop.initialize(setModuleImports, getAssemblyExports);

        const container = document.getElementById('canvasContainer');
        const containerId = container.id;

        await canvasInterop.registerPanel(containerId, container);

        const loadPdfButton = document.getElementById('loadPdf');
        const pdfFileInput = document.getElementById('pdfFileInput');
        const prevPageButton = document.getElementById('prevPage');
        const nextPageButton = document.getElementById('nextPage');
        const pageInfo = document.getElementById('pageInfo');

        let currentPageState = { currentPage: 0, pageCount: 0 };

        canvasInterop.setOnStateChanged(containerId, (state) => {
            currentPageState = state;
            pageInfo.textContent = state.pageCount > 0
                ? `Page ${state.currentPage} of ${state.pageCount}`
                : '-';
            prevPageButton.disabled = state.pageCount === 0 || state.currentPage <= 1;
            nextPageButton.disabled = state.pageCount === 0 || state.currentPage >= state.pageCount;
        });

        prevPageButton.addEventListener('click', () => {
            if (currentPageState.currentPage > 1) {
                canvasInterop.setPage(containerId, currentPageState.currentPage - 1);
            }
        });

        nextPageButton.addEventListener('click', () => {
            if (currentPageState.currentPage < currentPageState.pageCount) {
                canvasInterop.setPage(containerId, currentPageState.currentPage + 1);
            }
        });

        loadPdfButton.addEventListener('click', () => {
            pdfFileInput.value = '';
            pdfFileInput.click();
        });

        pdfFileInput.addEventListener('change', async (event) => {
            const file = event.target.files && event.target.files[0];
            if (!file) {
                return;
            }
            const arrayBuffer = await file.arrayBuffer();
            await canvasInterop.setDocument(containerId, new Uint8Array(arrayBuffer));
            canvasInterop.requestRedraw(containerId);
        });
    </script>
</body>
</html>
