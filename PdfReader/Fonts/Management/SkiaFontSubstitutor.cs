using PdfReader.Fonts.Model;
using PdfReader.Models;
using SkiaSharp;
using System;
using System.Collections.Generic;

namespace PdfReader.Fonts.Management;

/// <summary>
/// Utility class for PDF font substitution and style detection.
/// </summary>
internal sealed class SkiaFontSubstitutor : IDisposable
{
    private static readonly Dictionary<string, string[]> MergedFamilyMap = new Dictionary<string, string[]>(StringComparer.OrdinalIgnoreCase)
    {
        { "Times", new[] { "Times New Roman", "Times", "Liberation Serif", "Nimbus Roman" } },
        { "TimesNewRoman", new[] { "Times New Roman", "Times", "Liberation Serif", "Nimbus Roman" } },
        { "TimesNewRomanPS", new[] { "Times New Roman", "Times", "Liberation Serif", "Nimbus Roman" } },
        { "Helvetica", new[] { "Helvetica", "Arial", "Liberation Sans", "Nimbus Sans" } },
        { "Arial", new[] { "Arial", "Helvetica", "Liberation Sans", "Nimbus Sans" } },
        { "Courier", new[] { "Courier New", "Courier", "Liberation Mono", "Nimbus Mono" } },
        { "CourierNew", new[] { "Courier New", "Courier", "Liberation Mono", "Nimbus Mono" } },
        { "CourierNewPS", new[] { "Courier New", "Courier", "Liberation Mono", "Nimbus Mono" } },
        { "Symbol", new[] { "Symbol", "Segoe UI Symbol" } },
        { "ZapfDingbats", new[] { "Zapf Dingbats", "Segoe UI Symbol", "Wingdings" } },
        { "LiberationSans", new[] { "Liberation Sans", "Helvetica", "Arial", "Nimbus Sans" } },
        { "LiberationSerif", new[] { "Liberation Serif", "Times New Roman", "Times", "Nimbus Roman" } },
        { "LiberationMono", new[] { "Liberation Mono", "Courier New", "Courier", "Nimbus Mono" } },
        { "DejaVuSans", new[] { "DejaVu Sans", "Liberation Sans", "Arial", "Helvetica" } },
        { "DejaVuSerif", new[] { "DejaVu Serif", "Liberation Serif", "Times New Roman", "Times" } },
        { "DejaVuSansMono", new[] { "DejaVu Sans Mono", "Liberation Mono", "Courier New", "Courier" } },
        { "NimbusSans", new[] { "Nimbus Sans", "Helvetica", "Arial", "Liberation Sans" } },
        { "NimbusRoman", new[] { "Nimbus Roman", "Times New Roman", "Times", "Liberation Serif" } },
        { "NimbusMono", new[] { "Nimbus Mono", "Courier New", "Courier", "Liberation Mono" } },
        { "SourceSansPro", new[] { "Source Sans Pro", "Helvetica", "Arial", "Liberation Sans" } },
        { "SourceSerifPro", new[] { "Source Serif Pro", "Times New Roman", "Times", "Liberation Serif" } },
        { "SourceCodePro", new[] { "Source Code Pro", "Courier New", "Courier", "Liberation Mono" } },
        { "DroidSans", new[] { "Droid Sans", "Helvetica", "Arial", "Liberation Sans" } },
        { "DroidSerif", new[] { "Droid Serif", "Times New Roman", "Times", "Liberation Serif" } },
        { "DroidSansMono", new[] { "Droid Sans Mono", "Liberation Mono", "Courier New", "Courier" } },
        { "HelveticaNeue", new[] { "Helvetica Neue", "Helvetica", "Arial", "Liberation Sans" } },
        { "ArialUnicodeMS", new[] { "Arial Unicode MS", "Arial", "Helvetica" } },
        { "SegoeUI", new[] { "Segoe UI", "Arial", "Helvetica" } },
        { "SegoeUISymbol", new[] { "Segoe UI Symbol", "Segoe UI", "Arial", "Symbol" } },
        { "SegoeUIEmoji", new[] { "Segoe UI Emoji", "Segoe UI Symbol", "Segoe UI" } }
    };

    private readonly Dictionary<PdfFontName, SKTypeface> _typefaceCache = new Dictionary<PdfFontName, SKTypeface>();

    /// <summary>
    /// Attempts to match a non-embedded font by normalized stem and style, then falls back to known family substitutions.
    /// Caches resolved typefaces by PdfFontName.
    /// </summary>
    /// <param name="baseFont">PDF font base name.</param>
    /// <param name="fontDescriptor">Font descriptor for style hints.</param>
    /// <returns>Matching SKTypeface or SKTypeface.Default if not found.</returns>
    public SKTypeface SubstituteTypeface(PdfString baseFont, PdfFontDescriptor fontDescriptor)
    {
        var parsed = PdfFontName.Parse(baseFont, fontDescriptor);
        // TODO: PdfFontName should be generated by caller, we substitute font for every char individually, best to achieve by separate cache layer.

        if (_typefaceCache.TryGetValue(parsed, out var cachedTypeface))
        {
            return cachedTypeface;
        }

        SKFontStyle style = SKFontStyle.Normal;
        if (parsed.BoldHint && parsed.ItalicHint)
        {
            style = SKFontStyle.BoldItalic;
        }
        else if (parsed.BoldHint)
        {
            style = SKFontStyle.Bold;
        }
        else if (parsed.ItalicHint)
        {
            style = SKFontStyle.Italic;
        }

        // Stage 1: direct match using normalized stem itself
        var direct = SKFontManager.Default.MatchFamily(parsed.NormalizedStem, style);
        if (direct != null)
        {
            _typefaceCache[parsed] = direct;
            return direct;
        }

        // Stage 2: fallback list
        if (MergedFamilyMap.TryGetValue(parsed.NormalizedStem, out var list))
        {
            for (int i = 0; i < list.Length; i++)
            {
                var tf = SKFontManager.Default.MatchFamily(list[i], style);
                if (tf != null)
                {
                    _typefaceCache[parsed] = tf;
                    return tf;
                }
            }
        }

        // Stage 3: fallback to default with style
        var defaultWithParameters = SKTypeface.FromFamilyName(default, style);
        if (defaultWithParameters != null)
        {
            _typefaceCache[parsed] = defaultWithParameters;
            return defaultWithParameters;
        }

        // Final fallback: default typeface
        _typefaceCache[parsed] = SKTypeface.Default;
        return SKTypeface.Default;
    }

    public void Dispose()
    {
        foreach (var kvp in _typefaceCache)
        {
            kvp.Value?.Dispose();
        }
        _typefaceCache.Clear();
    }
}