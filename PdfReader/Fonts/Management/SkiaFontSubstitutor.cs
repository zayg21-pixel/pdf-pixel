using PdfReader.Fonts.Model;
using PdfReader.Models;
using SkiaSharp;
using System;
using System.Collections.Generic;

namespace PdfReader.Fonts.Management;

/// <summary>
/// Utility class for PDF font substitution and style detection.
/// </summary>
internal sealed class SkiaFontSubstitutor : IDisposable
{
    private static readonly Dictionary<string, Standard14Info> Standard14Map = new Dictionary<string, Standard14Info>(StringComparer.OrdinalIgnoreCase)
    {
        { "Times", new Standard14Info(new[] { "Times New Roman", "Times", "Liberation Serif", "Nimbus Roman" }, PdfFontEncoding.StandardEncoding) },
        { "TimesNewRoman", new Standard14Info(new[] { "Times New Roman", "Times", "Liberation Serif", "Nimbus Roman" }, PdfFontEncoding.StandardEncoding) },
        { "TimesNewRomanPS", new Standard14Info(new[] { "Times New Roman", "Times", "Liberation Serif", "Nimbus Roman" }, PdfFontEncoding.StandardEncoding) },
        { "Helvetica", new Standard14Info(new[] { "Helvetica", "Arial", "Liberation Sans", "Nimbus Sans" }, PdfFontEncoding.StandardEncoding) },
        { "Arial", new Standard14Info(new[] { "Arial", "Helvetica", "Liberation Sans", "Nimbus Sans" }, PdfFontEncoding.StandardEncoding) },
        { "Courier", new Standard14Info(new[] { "Courier New", "Courier", "Liberation Mono", "Nimbus Mono" }, PdfFontEncoding.StandardEncoding) },
        { "CourierNew", new Standard14Info(new[] { "Courier New", "Courier", "Liberation Mono", "Nimbus Mono" }, PdfFontEncoding.StandardEncoding) },
        { "CourierNewPS", new Standard14Info(new[] { "Courier New", "Courier", "Liberation Mono", "Nimbus Mono" }, PdfFontEncoding.StandardEncoding) },
        { "Symbol", new Standard14Info(new[] { "Times New Roman", "Segoe UI Symbol" }, PdfFontEncoding.SymbolEncoding) },
        { "ZapfDingbats", new Standard14Info(new[] { "Zapf Dingbats", "Segoe UI Symbol", "Wingdings" }, PdfFontEncoding.ZapfDingbatsEncoding) }
    };

    private readonly Dictionary<PdfFontName, SKTypeface> _typefaceCache = new Dictionary<PdfFontName, SKTypeface>();

    /// <summary>
    /// Attempts to match a non-embedded font by normalized stem and style, then falls back to known family substitutions.
    /// Caches resolved typefaces by PdfFontName.
    /// </summary>
    /// <param name="baseFont">PDF font base name.</param>
    /// <param name="fontDescriptor">Font descriptor for style hints.</param>
    /// <returns>Matching SKTypeface or SKTypeface.Default if not found.</returns>
    public SKTypeface SubstituteTypeface(PdfString baseFont, string unicode, PdfFontDescriptor fontDescriptor)
    {
        var parsed = PdfFontName.Parse(baseFont, fontDescriptor);
        // TODO: PdfFontName should be generated by caller, we substitute font for every char individually, best to achieve by separate cache layer.
        // TODO: refactor this method entirely.

        //if (_typefaceCache.TryGetValue(parsed, out var cachedTypeface))
        //{
        //    return cachedTypeface;
        //}

        SKFontStyle style = SKFontStyle.Normal;
        if (parsed.BoldHint && parsed.ItalicHint)
        {
            style = SKFontStyle.BoldItalic;
        }
        else if (parsed.BoldHint)
        {
            style = SKFontStyle.Bold;
        }
        else if (parsed.ItalicHint)
        {
            style = SKFontStyle.Italic;
        }

        // Stage 1: direct match using normalized stem itself
        //var direct = SKFontManager.Default.MatchFamily(parsed.NormalizedStem, style);

        //if (direct != null && (unicode == null || direct.ContainsGlyphs(unicode)))
        //{
        //    _typefaceCache[parsed] = direct;
        //    return direct;
        //}

        // Stage 2: fallback list
        if (Standard14Map.TryGetValue(parsed.NormalizedStem, out var info))
        {
            var list = info.SubstitutionCandidates;
            for (int i = 0; i < list.Length; i++)
            {
                var tf = SKFontManager.Default.MatchFamily(list[i], style);
                if (tf != null && (unicode == null || tf.ContainsGlyphs(unicode)))
                {
                    _typefaceCache[parsed] = tf;
                    return tf;
                }
            }
        }

        if (unicode != null && unicode.Length >= 1)
        {
            // Additional attempt: try to find any font that contains the glyph
            var anyFont = SKFontManager.Default.MatchCharacter(default, style, default, unicode[0]);
            if (anyFont != null)
            {
                _typefaceCache[parsed] = anyFont;
                return anyFont;
            }
        }

        // Stage 3: fallback to default with style
        var defaultWithParameters = SKTypeface.FromFamilyName(default, style);
        if (defaultWithParameters != null)
        {
            _typefaceCache[parsed] = defaultWithParameters;
            return defaultWithParameters;
        }

        // Final fallback: default typeface
        _typefaceCache[parsed] = SKTypeface.Default;
        return SKTypeface.Default;
    }

    /// <summary>
    /// Returns the expected encoding for a given standard 14 PDF font name.
    /// For non-standard fonts, returns null.
    /// For Symbol and ZapfDingbats, returns their respective encodings.
    /// </summary>
    /// <param name="baseFont">The PDF BaseFont name.</param>
    /// <returns>The expected PdfFontEncoding for the font name.</returns>
    public static PdfFontEncoding? GetEncodingByName(PdfString baseFont)
    {
        if (baseFont.IsEmpty)
        {
            return default;
        }

        var parsed = PdfFontName.Parse(baseFont, default);
        string stem = parsed.NormalizedStem;

        if (Standard14Map.TryGetValue(stem, out var info))
        {
            return info.DefaultEncoding;
        }

        return default;
    }

    public void Dispose()
    {
        foreach (var kvp in _typefaceCache)
        {
            kvp.Value?.Dispose();
        }
        _typefaceCache.Clear();
    }
}